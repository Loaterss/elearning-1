import psycopg2
from math import sqrt

class UserCF:
    def __init__(self, k=2, top_k = 4):
        
        self.database = "postgres"
        self.user = "postgres"
        self.password = "meilei"
        self.host = "127.0.0.1"
        self.port = "5432"
        self.selectSql = "SELECT * FROM public.SUBJECT_RATING"
    
        self.k = k

        self.topK = top_k
        
        self.ratingMatrix = {}
        self.loadRatingMatrix()
        
        self.items = []
        self.getItems()
    
    def conn(self):
        conn = psycopg2.connect(database=self.database, user=self.user, password=self.password, host=self.host, port=self.port)
        cur = conn.cursor()
        cur.execute(self.selectSql)
        rows = cur.fetchall()

        conn.commit()
        cur.close()
        conn.close()
        return rows
    
    def loadRatingMatrix(self):
        
        records = self.conn()

        for record in records:
            subjectId = record[1]
            userId = record[2]
            rating = int(record[3])
            
            if userId in self.ratingMatrix.keys():
                userRatings = self.ratingMatrix[userId]
            
            else:
                userRatings = {}
            
            userRatings[subjectId] = rating
            
            self.ratingMatrix[userId] = userRatings
    
    def getNeighborUsers(self, userId):
        
        distances = []
        
        for otherUserId in self.ratingMatrix.keys():
            if otherUserId != userId:
                
                distance = self.computeSimilarity(self.ratingMatrix[userId], self.ratingMatrix[otherUserId])
                
                if distance <= 0:
                    continue

                distances.append((otherUserId, distance))
        
        distances.sort(key=lambda artistTuple: artistTuple[1],
                       reverse=True)
        print(distances)
        return distances
    
    def computeSimilarity(self, rating1, rating2):
        sum_xy = 0
        sum_x = 0
        sum_y = 0
        sum_x2 = 0
        sum_y2 = 0
        n = 0
        for key in rating1:
            if key in rating2:
                n += 1
                x = rating1[key]
                y = rating2[key]
                sum_xy += x * y
                sum_x += x
                sum_y += y
                sum_x2 += pow(x, 2)
                sum_y2 += pow(y, 2)
        if n == 0:
            return 0
        denominator = (sqrt(sum_x2 - pow(sum_x, 2) / n)
                       * sqrt(sum_y2 - pow(sum_y, 2) / n))
        if denominator == 0:
            return 0
        else:
            return (sum_xy - (sum_x * sum_y) / n) / denominator
    
    def getRecommendations(self, userId):
        
        userRatings = self.ratingMatrix[userId]
        print("User: {}, Ratings: {}".format(userId, userRatings))
        
        neighborUsers = self.getNeighborUsers(userId)
        print("Neighbor Users::", neighborUsers)
        
        averageUserRating = self.getAverageRating(userId)
        print("User {} average rating: {}".format(userId, averageUserRating))
        
        ratedItems = userRatings.keys()
        print("User {} rated items: {}".format(userId, ratedItems))
        
        notRatedItems = [item for item in self.items if item not in ratedItems]
        print("User {} not rated items: {}".format(userId, notRatedItems))
        
        predictions = {}
        
        UsedNeighborUserNumber = min(len(neighborUsers), self.k)
        
        for item in notRatedItems:
            
            itemNotAppearNumbers = 0
            for i in range(UsedNeighborUserNumber):
                neighborUser = neighborUsers[i][0]
                if item not in self.ratingMatrix[neighborUser]:
                    itemNotAppearNumbers += 1
            
            if itemNotAppearNumbers == UsedNeighborUserNumber:
                predictions[item] = averageUserRating
            
            else:
                neighRating = 0
                neighSimSum = 0
                
                for i in range(UsedNeighborUserNumber):
                    
                    neighborUser = neighborUsers[i][0]
                    
                    averageNeighborUserRating = self.getAverageRating(neighborUser)
                    
                    neighborRatings = self.ratingMatrix[neighborUser]
                    
                    if item not in neighborRatings:
                        continue

                    neighRating += (neighborRatings[item] - averageNeighborUserRating) * neighborUsers[i][1]
                    neighSimSum += abs(neighborUsers[i][1])

                if neighSimSum == 0:
                    predictions[item] = averageUserRating
                else:
                    predictions[item] = averageUserRating + neighRating / neighSimSum

        recommendItems = []
        sortedPredictions = sorted(predictions.items(),key=lambda x:x[1],reverse=True)
        for item, rating in sortedPredictions:
            recommendItems.append(item)
        return recommendItems[:self.topK]

    def getItems(self):
        items = []
        for user, userRatings in self.ratingMatrix.items():
            items.extend(list(userRatings.keys()))
        self.items = list(set(items))

    def getAverageRating(self, userId):
        averange = sum(self.ratingMatrix[userId].values()) / len(self.ratingMatrix[userId].keys())
        return averange

if __name__ == '__main__':
    model = UserCF()
    recommendations = model.getRecommendations(5)
    print(recommendations)
